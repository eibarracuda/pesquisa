---
{"dg-publish":true,"permalink":"/04-cadernos/2023-04-08-bash/","tags":["ğŸ§ ï¸/ğŸ“ï¸/ğŸŒ±ï¸"],"created":"2023-04-08 16:07","updated":"2023-05-17 15:22"}
---






# ğŸŒ±ï¸ 2023-04-08 - ğŸ“ï¸ Bash
<small>08/04/2023</small>


## Notas

Terminal do GIT
![Pasted image 20230407191256.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230407191256.png)

![Pasted image 20230407191711.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230407191711.png)

```bash
$ pwd
/home/lucas
```

```bash
echo "Bem vindo"
```

```bash
echo "Bem vindo" > bemvindo.txt

echo "REM" > musicas-favoritas.txt
echo "Faithless" >> musicas-favoritas.txt
```

```bash
ls
```

O comandoÂ `ls`Â nos retorna o conteÃºdo do diretÃ³rio atual. No terminal do Ubuntu, ele separa o tipo do conteÃºdo (arquivo ou diretÃ³rio) pela cor.

```bash
man ls
```

```bash
cd Desktop
```

```bash
mkdir workspace   %% criar diretorio
rmdir projetos-java   %% deletar diretorio
rm arquivo3.txt      %% remover diretorio

rm -r workspace/
```

### Caracteres coringa

```shell
$ cat arquivo*.txt
bem vindo
meu primeiro teste
meu primeiro teste
meu primeiro teste
```

```shell
$ cat *.txt
bem vindo
meu primeiro teste
meu primeiro teste
meu primeiro teste
```

### Copiando, movendo e renomeando

Vamos criar novamente o diretÃ³rioÂ _workspace_Â - para nÃ£o trabalharmos na raiz doÂ _HD_:

```bash
mkdir workspace
cd workspace/
```

Vamos colocar uma mensagem em um arquivo qualquer dentro do diretÃ³rio criado:

```bash
echo "bem vindo" > mensagem.txt
```

Vamos copiar o texto do arquivo que acabamos de criar para um outro de nome "bemvindo.txt" com o comandoÂ `cp`:

```bash
cp mensagem.txt bemvindo.txt
```

O texto agora estÃ¡ nos dois arquivos:

```bash
cat bemvindo.txt
bem vindo
cat mensagem.txt
bem vindo
```

Podemos tambÃ©m mover o arquivo "mensagem.txt" para outro com o comandoÂ `mv`:

```bash
mv mensagem.txt bemvindo2.txt

ls
bemvindo2.txt   bemvindo.txt
```

Perceba que o arquivo mudou de nome.

Criemos agora mais dois diretÃ³rios:

```bash
mkdir projetos-java
mkdir projetos-php
```

Queremos mover o arquivo "bemvindo.txt" para dentro do diretÃ³rio "projetos-java":

```bash
mv bemvindo.txt projetos-java/
```

Se quisÃ©ssemos alÃ©m de movÃª-lo, mudar seu nome, farÃ­amos, por exemplo:

```bash
mv bemvindo.txt projetos-java/bemvindo-novo-nome.txt
```

Vamos verificar se ele foi realmente movido para o diretÃ³rio que querÃ­amos:

```bash
ls workspace/
bemvindo2.txt   projetos-java   projetos-php

ls projetos-java/
bemvindo.txt
```

De fato, o arquivo "bemvindo.txt" saiu doÂ _workspace_Â e foi para oÂ _projetos-java_. Vamos copiar "bemvindo2.txt" com o nome "bemvindo.txt" para manter este nos dois diretÃ³rios:

```bash
cp bemvindo2.txt bemvindo.txt

ls workspace/
bemvindo2.txt   bemvindo.txt   projetos-java   projetos-php
```

Se quisermos buscar os dois arquivos "bemvindos" dentro do diretÃ³rioÂ _workspace_, fazemos:

```bash
ls bemvindo*
bemvindo2.txt   bemvindo.txt
```

Perceba que quando usamos o comandoÂ `ls`Â para arquivos, o terminal retorna tais arquivos. Se fizermos o mesmo para diretÃ³rios, ele retorna o que estiver dentro deles. E, ainda, se fizermosÂ `ls *`, o terminal retorna:

```makefile
bemvindo2.txt   bemvindo.txt

projetos-java:
bemvindo.txt

projetos-php:
```

Ou seja, mostra tanto os diretÃ³rios dentro daquele em que estamos trabalhando e seus respectivos arquivos.

Assim como utilizamos oÂ `-r`Â para conseguirmos apagar diretÃ³rios, do mesmo jeito fazemos para copiÃ¡-los, como por exemplo:

```bash
cp -r projetos-java projetos-c#
```

Nesta aula aprendemos a mover, renomear e copiar arquivos e diretÃ³rios.

***
***
![Pasted image 20230408150132.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230408150132.png)

![Pasted image 20230408152257.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230408152257.png)
***
![Pasted image 20230408154352.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230408154352.png)

### VI

```bash
vi google.txt

```
-   Setas: para navegaÃ§Ã£o
-   i: inclui (na posiÃ§Ã£o atual)
-   a: adiciona (na posiÃ§Ã£o posterior)
-   Shift+A: adiciona (fim da linha)
-   x: remove caracteres (_n* x remove *n_Â caracteres)
-   dd: remove uma linha (_n* dd remove *n_Â linhas)



```bash
vi google.txt
:wq  -- salva e sai
:q!  -- sair ignorando alteraÃ§Ãµes
```

Se quisermos ir para a Ãºltima linha do texto por exemplo, basta apertarmosÂ `Shift + g`. Se quisermos pular para a linhaÂ _n_, apertamos o nÃºmero correspondente e depoisÂ `Shift + g`. EntÃ£o se, por exemplo, quisermos ir para a linha 5, fazemosÂ `5`Â e depoisÂ `Shift + g`, para a primeira linha a combinaÃ§Ã£o tambÃ©m Ã© vÃ¡lida:Â `1`Â e depoisÂ `Shift + g`, sempre comÂ `Shift`Â para que oÂ `g`Â seja maiÃºsculo.

Algo bem comum ligado Ã  navegaÃ§Ã£o de um arquivo Ã© a procura de palavras. Para buscarmos palavras no texto usando oÂ _VI_, digitamos "/" + o texto que procuramos, algo como:

```undefined
/California
```

Se digitarmos isso, o cursor vai para a primeira ocorrÃªncia da palavraÂ `California`. Se apertarmos a teclaÂ `n`, ele irÃ¡ para a prÃ³xima ocorrÃªncia e comÂ `Shift + n`, podemos voltar para a anterior.

Para conseguir navegar atÃ© o fim do arquivo, utilizamos o comandoÂ `G (Shift + g)`. Para navegar atÃ© o inÃ­cio do arquivo, utilizamos o comandoÂ `1G (Shift + g)`.
    
Para ir atÃ© o inÃ­cio do arquivo, podemos utilizar tambÃ©m o comandoÂ `gg`.

Para ir atÃ© o inÃ­cio de uma linha, utilizamos o comandoÂ `0`Â e para ir atÃ© o final de uma linha, utilizamos o comandoÂ `$`.

Se quisermos navegar atÃ© a linha de nÃºmero 30, utilizamos o comandoÂ `30G (Shift + g)`. Podemos tambÃ©m utilizar o comandoÂ `30gg`.

Um recurso muito comum de ser utilizado nas ediÃ§Ãµes de texto sÃ£o o copiar e colar, os quais veremos como fazer noÂ _VI_. Para copiarmos uma linha do texto apertamos a teclaÂ `y`Â duas vezes e para colar o que foi copiado, basta usar a teclaÂ `p`.

TambÃ©m podemos usar a ideia de quantidade de linhas com os nÃºmeros para copiar e colar. Se quisermos copiar a linha atual e mais as duas linhas abaixo podemos fazerÂ `3`Â eÂ `yy`Â - trÃªs linhas foram copiadas. O mesmo serve para o comando de colar:Â `3`Â eÂ `p`Â cola trÃªs vezes o conteÃºdo copiado anteriormente.













### Outras notas nessa mesma fase de desenvolvimento ou com as mesmas palavras chaves
````` dataview
table created AS "Criado em", tags AS "Tags", tema AS "Tema", keywords, status AS "Status"
from ""
where contains(tags, "#ğŸ§ ï¸/ğŸ“ï¸/`") OR contains(keywords, "undefined") and folhan != "undefined"
``````

***



## [[â 2023-04-18 - ğŸ’ Linux II - programas, processos e pacotes| â† â 2023-04-18 - ğŸ’ Linux II - programas, processos e pacotes]] | [[2023-04-18]] 
`ls` + rapido
`firefox` + cpu 
`gedit` + cpu 
`mkdir` + rÃ¡pido

### `ps`
- Processos sendo executados no terminal


```bash
ps                       # processos sendo executados no terminal (imagem 1)
ps -e                    # processos do sistema (imagem 2)
ps -ef                   # mostra a localizaÃ§Ã£o dos programas, quando foram inicializados e outras infos (img 3)
ps -ef | grep NomeDoPrograma   #  filtragem de dados dada uma entrada
```

Imagem 1:
![Pasted image 20230418164827.png|Imagem 1](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418164827.png)<br>
Imagem 2:
![Pasted image 20230418165228.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418165228.png)
Imagem 3:
![Pasted image 20230418165548.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418165548.png)



### `kill`

```bash
kill 16546      # usando o ID do processo, encerra sozinho

kill -9 16546      # usando o ID, o processo Ã© encerrado imediatamente

$ kill -STOP 11163     # Parar
$ kill -CONT 11163     # Continuar
$ kill -TERM 11269     # Executado por  padrÃ£o

$ top                  # mostra o processo por consumo
top -u marta           # Processos de um usuÃ¡rio
$ killall -9 top
```

![Pasted image 20230418165339.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418165339.png)


### `grep`

```bash
grep California google.txt
```

utilizaremos sempre que precisarmos encontrar os processos que queremos encerrar ou obter informaÃ§Ãµes.

`jobs`: mostra os processos que estÃ£o sendo executados dentro doÂ _bash_;
-   `fg`Â eÂ `bg`: jogam os processos paraÂ _foreground_Â eÂ _background_, respectivamente;
-   `[programa] &`: abre o [programa] diretamente emÂ _background_;
-   `pstree`: mostra todos os processos em um grÃ¡fico de Ã¡rvore.
O comando que nos mostra a Ã¡rvore de processos Ã© oÂ `pstree`

### `sh`

```bash
gedit dorme &

# codigo (n no bash)
echo "Vou dormir"
sleep 5
echo "Terminei de dormir"

sh dorme
```

![Pasted image 20230418195503.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418195503.png)

![Pasted image 20230418195621.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418195621.png)

![Pasted image 20230418195717.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418195717.png)
### `chmod`

```bash
chmod +x dorme

./dorme
```


![Pasted image 20230418195802.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418195802.png)

![Pasted image 20230418195816.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418195816.png)

### `locate` e `updatedb`

```undefined
locate firefox  # pode nos apresentar dados desatualizados na busca, pois sua base de pesquisa Ã© atualizada apenas de tempos em tempos

$ locate *.txt

$ locate realizabackup
/home/lucas/scripts/realizabackup

sudo updatedb  # para atualizar

sudo mv dorme /usr/bin

which dorme      # descobrir o caminho onde se encontra o arquivo de um comando

```

### Controle de usuÃ¡rios

```bash
adduser jose # add user

chmod o-rx jose     # `o`Â paraÂ _others_, ou seja, outros usuÃ¡rios, oÂ `-`Â indica uma remoÃ§Ã£o de permissÃ£o, oÂ `r`Â eÂ `x`Â indicam permissÃµes de leitura e execuÃ§Ã£o

sudo passwd  # senha para o usuario root

su root # logar com root

$ su usuario    # logar com algum usuÃ¡rio
Password:
$ su
Password:
```


```sql
$ sudo adduser jose
Adding user `jose' ...
Adding new group `jose' (1002) ...
Adding new user `jose' (1002) with group `jose' ...
Creating home directory `/home/jose' ...
Copying files from `/etc/skel' ...
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
Changing the user information for jose
Enter the new value, or press ENTER for the default
    Full Name []:
    Room Number []:
    Work Phone []:
    Home Phone []:
    Other []:
Is the information correct? [Y/n] Y
```

```shell
$ su jose
Password:
$ cd /home/
$ chmod o-rx jose/
```

```lua
$ ls -l
total 28
drwxr-x---  2 jose  jose   4096 Jan 31 06:30 jose
drwx------  2 root  root  16384 Jan 16 17:07 lost+found
drwxr-xr-x 31 lucas lucas  4096 Jan 31 06:11 lucas
d-wx-wx--x  2 nico  nico   4096 Jan 30 16:53 nico
```

***

### VariÃ¡veis de ambiente e PATH


```ruby
PATH=$PATH:/home/guilherme/workspace

env | grep PATH

gedit .bashrc &

```

### Contagens

```shell
$ wc -w *.txt
 6 projetos_java.txt
10 projetos_php.txt
16 total
```

```bash
wc -w *.txt | grep total
```

```bash
$ echo $PS1
\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$
```

uando estamos utilizando o terminal, algumas informaÃ§Ãµes sempre sÃ£o mostradas, exemplo:Â `lucas@lucas-Inspiron-5458:~$`. Essa formataÃ§Ã£o Ã© definida na variÃ¡velÂ `PS1`.

Experimente alterar a variÃ¡vel e perceba que a definiÃ§Ã£o do seu prompt serÃ¡ alterada:

```ruby
lucas@lucas-Inspiron-5458:~$ PS1="alura>"
alura>
alura>PS1="alura:"
alura:
```

### InstalaÃ§Ã£o de programas: apt

Nesta aula vamos aprender como instalar um programa via Terminal de Linux. Como exemplo, iremos instalar um servidor FTP.

O Ubuntu nos disponibiliza um sistema de gerenciamento de pacotes chamadoÂ **_apt_**. Para ver as versÃµes atualizadas dos programas que estÃ£o disponÃ­veis para instalaÃ§Ã£o fazemos:

```sql
sudo apt-get update
```

Veja que executamos o comando comoÂ _root_Â (`sudo`), isto porque esta Ã© uma tarefa de administraÃ§Ã£o, por isso Ã© necessÃ¡rio que seja feita comoÂ _root_, caso nÃ£o, teremos uma mensagem de permissÃ£o negada. Neste passo, o Terminal irÃ¡ buscar na internet o que existe de novidade nos programas para instalaÃ§Ã£o. Para buscar um programa de servidor FTP podemos fazer:

```sql
apt-cache search ftp
```

Este comando busca na lista de pacotes disponÃ­veis, qualquer programa que se encaixe nesse termo de busca, por isso retorna uma longa lista de programas. Sejamos mais restritos na busca e procuremos um servidor especÃ­fico:

```sql
apt-cache search vsftp
```

Como estamos usando uma busca mais restrita, poucos resultados serÃ£o retornados pela busca, a imagem abaixo ilustra esses resultados.

![resultados de busca para vsftp](https://s3.amazonaws.com/caelum-online-public/linux2/a9v1-vsftp.png)

Achamos um bom servidor FTP, ele nos mostra o nome e uma curta descriÃ§Ã£o. Para instalar este programa fazemos:

```csharp
sudo apt-get install vsftpd
```

E apÃ³s alguns segundos o programa estÃ¡ instalado! SerÃ¡ mesmo? Para testarmos, podemos tentar conectar ao servidor da prÃ³pria mÃ¡quina utilizando o comando:

```undefined
ftp localhost
```

```csharp
$ sudo apt-get install vsftpd
[sudo] password for lucas:
```

Para realizar um teste, podemos nos conectar na nossa mÃ¡quina:

```scss
$ ftp localhost
Connected to localhost.
220 (vsFTPd 3.0.2)
Name (localhost:lucas):
```


SerÃ¡ pedido um usuÃ¡rio e senha para podermos acessar a mÃ¡quina.

![conectando via ftp](https://s3.amazonaws.com/caelum-online-public/linux2/a9v1-login-ftp.png)

Depois disso podemos manipular os arquivos via FTP executando quaisquer comandos que jÃ¡ aprendemos atÃ© agora, comoÂ `ls`Â e outros.

> Para encerrar a conexÃ£o, usamos o comandoÂ `exit`. Experimente conectar com outros usuÃ¡rios disponÃ­veis na maquina tambÃ©m.

Para que possamos remover programas, utilizamos o comandoÂ `apt-get remove`Â seguido do nome do programa. Como exemplo, vamos desinstalar o servidor que instalamos.

```csharp
sudo apt-get remove vsftpd
```

SerÃ¡ pedida uma confirmaÃ§Ã£o e depois a desinstalaÃ§Ã£o seguirÃ¡ normalmente. Garanta que a desinstalaÃ§Ã£o foi feita com sucesso tentando fazer login via FTP novamente. Caso o programa realmente tenha sido desinstalado, uma mensagem de erro semelhante a seguinte deve ser impressa no Terminal.

```makefile
ftp: connect: Connection refused
```

Aprendemos a instalar e desinstalar programas de forma fÃ¡cil e prÃ¡tica com auxilio do gerenciador de pacotesÂ `apt`. Os comandos sÃ£o:

-   `apt-get install`: instala um programa dado o nome
-   `apt-get remove`: desinstala um programa dado o nome
-   `apt-get update`: busca uma lista das versÃµes atualizadas dos programas
-   `apt-cache search`: procura os programas disponÃ­veis para instalaÃ§Ã£o

### Novos programas com dpkg

Podemos instalar programas que nÃ£o estÃ£o disponibilizados na central de programas do Ubuntu, ou seja, sem o uso doÂ `apt`. Para isso nÃ³s baixamos um pacote desse programa em um site e depois o instalamos. O formato desse pacote Ã©Â _dpkg_, que Ã© um arquivo com a extensÃ£oÂ _.deb_.

Vamos instalar novamente o servidor de FTP, porÃ©m, usando o pacoteÂ _.deb_. Procuramos na internet e baixamos via navegador oÂ `vsftpd`Â no endereÃ§o:Â [http://ftp.br.debian.org/debian/pool/main/v/vsftpd/vsftpd_3.0.2-17+deb8u1_i386.deb](http://ftp.br.debian.org/debian/pool/main/v/vsftpd/vsftpd_3.0.2-17+deb8u1_i386.deb). Ele estarÃ¡ salvo no diretÃ³rio deÂ _Downloads_. Para instalar entramos nesse diretÃ³rio com o comandoÂ `cd`Â e utilizando o comandoÂ `dpkg`Â fazemos:

```css
sudo dpkg -i vsftpd_3.0.2-17+deb8u1_i386.deb
```

OÂ `-i`Â indica que estamos instalando o programa. Lembre-se de que o nome do arquivo precisa ser fornecido e que o comando deve ser executado comoÂ _root_Â por causa de suas permissÃµes. E para desinstalar um programa peloÂ _dpkg_? Muito simples, fazemos:

```bash
sudo dpkg -r [nome do pacote]
```

Perceba que para a desinstalaÃ§Ã£o nÃ£o usamos o nome do arquivo baixado, mas sim o nome do pacote do programa, que neste caso Ã©Â `vsftpd`.

```undefined
sudo dpkg -r vsftpd
```

> Lembre-se de testar a instalaÃ§Ã£o e desinstalaÃ§Ã£o da mesma forma que fizemos na aula passada, efetue login, encerre a conexÃ£o, faÃ§a login com outros usuÃ¡rios, execute comandos via ftp.

EntÃ£o vimos duas formas de instalar e desinstalar programas no Linux:

1.  ViaÂ _apt_: quando o programa jÃ¡ estÃ¡ disponibilizado na central do Sistema Operacional Linux.
    
2.  ViaÂ _dpkg_: quando baixamos pelo navegador da internet um pacoteÂ _.deb_Â do programa.

```ruby
$ sudo dpkg -r google-chrome-stable
```

Uma vez que instalamos um pacote, podemos tambÃ©m remover com oÂ `apt-get`, passando a opÃ§Ã£oÂ `remove`:

```csharp
$ sudo apt-get remove google-chrome-stable
```

***


Para encerrar a execuÃ§Ã£o, fazemos:

```bash
sudo /etc/init.d/vsftpd stop
```

Para inicializa-lo novamente, fazemos:

```bash
sudo /etc/init.d/vsftpd start
```

### InstalaÃ§Ã£o a partir do cÃ³digo fonte

![Pasted image 20230418210954.png](/img/user/XX%20-%20Anexos/Pasted%20image%2020230418210954.png)

Vimos atÃ© agora duas maneiras de instalar um programa no Linux:

1.  ViaÂ `apt`: quando o programa jÃ¡ estÃ¡ disponibilizado na central de programas do Ubuntu.
    
2.  ViaÂ `dpkg`: quando baixamos pelo navegador um pacote do programa com a extensÃ£oÂ _.deb_.
    

PorÃ©m, Ã© possÃ­vel que um programa nÃ£o esteja disponÃ­vel em nenhuma das duas formas. Nesse caso vamos ter que baixar seu cÃ³digo fonte, compilÃ¡-lo e instalÃ¡-lo. Faremos um teste baixando o cÃ³digo fonte de um projeto, oÂ _Git_, um programa para controle de versÃ£o.

Primeiro vamos entrar no site doÂ _git-scm_Â emÂ [git-scm.com](https://git-scm.com/). Na abaÂ _Tarballs_Â encontramos as versÃµes compactadas do cÃ³digo fonte doÂ _Git_. LÃ¡, baixaremos a versÃ£oÂ `git-1.8.3.1.tar.gz`. Ã‰ importante que seja oÂ `tar.gz`Â por que o mesmo mantÃ©m as permissÃµes de execuÃ§Ã£o dos arquivos, enquanto umÂ _.zip_Â nÃ£o mantÃ©m.

No Terminal, entraremos no diretÃ³rio deÂ _Downloads_Â e descompactamos o arquivo com o comandoÂ `tar`:

```undefined
tar zxf git-1.8.3.1.tar.gz
```

SerÃ¡ criado um diretÃ³rio com nomeÂ `git-1.8.3.1`Â com vÃ¡riosÂ _scripts_Â que podem ser executados. Entraremos nele para os prÃ³ximos passos.

O padrÃ£o de criaÃ§Ã£o para instalaÃ§Ã£o de um projeto atravÃ©s do cÃ³digo fonte emÂ _C* Ã© primeiramente testarmos a configuraÃ§Ã£o da nossa mÃ¡quina, ou seja, verificar se estÃ¡ faltando algum arquivo ou programa em nossa mÃ¡quina que o *Git_Â precise para funcionar. Para isso, em geral, Ã© disponibilizado umÂ _script_Â chamado "_configure_". OÂ _Git_Â disponibiliza esseÂ _script_, Vamos executÃ¡-lo:

```bash
./configure
```

OÂ _script_Â `configure`Â farÃ¡ uma sÃ©rie de checagens em nossa mÃ¡quina, e ao fim, caso nenhum problema seja encontrado, poderemos usar o comandoÂ `make`, que Ã© o padrÃ£o para rodar oÂ _build_Â do projeto emÂ _C*, no caso do *Git_. PorÃ©m o comandoÂ `make`Â nos retorna a seguinte mensagem:

![zlib not found - nÃ£o encontrado o zlib](https://s3.amazonaws.com/caelum-online-public/linux2/a12v1-zlib.png)

O erro indica que nÃ£o foi encontrada a bibliotecaÂ `zlib.h`. OÂ _script_Â `configure`Â nÃ£o apontou essa falta. Vamos ter que instalÃ¡-la manualmente. Seu nome Ã©Â `zlib1g-dev`:

```csharp
sudo apt-get install zlib1g-dev
```

> Neste ponto, estamos informando diretamente o nome da biblioteca ser instalada, mas lembre-se, podemos buscar por seu nome atravÃ©s doÂ `apt-cache search zlib`Â e usar o comandoÂ `grep`Â para filtragem:Â `apt-cache search zlib | grep dev`

Agora sim oÂ `make`irÃ¡ funcionar e gerar oÂ _Git_. O prÃ³ximo passo Ã©, enfim, instalÃ¡-lo na nossa mÃ¡quina:

```go
sudo make install
```

> Caso nÃ£o haja nenhum erro, o comando git estarÃ¡ disponÃ­vel no terminal. Experimente digitarÂ `git`. Uma listagem de ajuda deverÃ¡ ser exibida.

Portanto, existem basicamente trÃªs passos para instalar um programa a partir de seu cÃ³digo fonte:

1.  `./configure`Â para verificar as dependÃªncias e configuraÃ§Ãµes da mÃ¡quina.
    
2.  `make`Â para gerar o programa, ou seja, compilar. Lembrando que, neste passo, pode haver outras dependÃªncias necessÃ¡rias para a tarefa e por isso talvez seja preciso realizar instalaÃ§Ãµes de outras bibliotecas.
    
3.  `sudo make install`Â para que o programa seja instalado em nossa mÃ¡quina. Lembrando que oÂ `sudo`Â Ã© necessÃ¡rio por causa de questÃµes de permissÃ£o.
    

Estes mesmos passos podem se repetir para determinados programas onde as dependÃªncias nÃ£o estejam disponÃ­veis atravÃ©s de arquivosÂ _.deb_Â ou na central de programas.

***
###  Acesso remoto

Vamos aprender nesta aula como acessar um servidor remoto no Linux. Para isso, teremos que fazer uma comunicaÃ§Ã£o com o outro servidor. JÃ¡ vimos o FTP, mas o FTP Ã© para troca de arquivos. O que queremos Ã© nosÂ _logar_Â como um usuÃ¡rio. Para isso iremos usar o SSH. O primeiro passo Ã© instalÃ¡-lo:

```csharp
sudo apt-get install ssh
```

Desta forma instala-se tanto o cliente SSH (`ssh-client`), quando o servidor (`ssh-server`). Para testarmos se o programa instalou corretamente, logaremos na nossa prÃ³pria mÃ¡quina utilizando o comandoÂ `ssh`, fornecendo o nome de um usuÃ¡rio jÃ¡ criado anteriormente e oÂ _ip_Â da mÃ¡quina.

```css
ssh jose@localhost
```

SerÃ¡ pedida a senha do usuÃ¡rioÂ `jose`Â e logo apÃ³s, estaremos logados no servidor remoto. Poderemos executar uma sÃ©rie de comandos, porÃ©m nÃ£o temos acesso Ã s ferramentas e programas grÃ¡ficos. NÃ£o podemos, por exemplo, abrir um navegador.

Para termos essa permissÃ£o, precisamos nos conectar usando um modificador que permita o uso de ferramentas grÃ¡ficas. OÂ `-X`Â Ã© esse modificador:

```css
ssh -X jose@localhost
```

> Para encerrar a conexÃ£o, usamos o comandoÂ `exit`Â da mesma forma que fizemos quando usamos oÂ `ftp`.

Lembrando que tudo o que estamos fazendo estÃ¡ sendo executado lÃ¡ no servidor e nÃ£o em nossa mÃ¡quina. Somente o grÃ¡fico Ã© mostrado em nossa mÃ¡quina, as aÃ§Ãµes sÃ£o todas remotas.

Agora vamos ver como copiar um arquivo da nossa mÃ¡quina local para a mÃ¡quina remota. Fazemos por meio do comandoÂ `scp`, indicando para ele qual Ã© o arquivo e qual Ã© o destino do arquivo:

```ruby
scp work.zip jose@localhost:/home/jose
```

`/home/jose`Â Ã© aÂ _home_Â do usuÃ¡rioÂ `jose`Â e pode ser substituÃ­do por "~":

```ruby
scp work.zip jose@localhost:~/
```

Com isso jogamos o arquivoÂ `work.zip`Â no nosso servidor remoto. Se o buscarmos dentro da outra mÃ¡quina, nos conectando novamente com oÂ `ssh`Â e listarmos os arquivos com o comandoÂ `ls`Â iremos perceber que realmente ele foi copiado.

Caso seja necessÃ¡ria a copia de arquivos de forma recursiva, pode-se utilizar a opÃ§Ã£oÂ `-r`Â assim como era feito com os comandosÂ `mv`Â eÂ `cp`.
### Realizando conexÃ£o via ssh

Instale o pacoteÂ `ssh`, que instalarÃ¡ tanto um cliente, para que consigamos nos conectar, quanto um servidor, para que possamos receber conexÃµes.

```csharp
sudo apt-get install ssh
```

Caso ainda nÃ£o tenha criado um usuÃ¡rio, vocÃª precisarÃ¡ fazer isso agora. Crie um usuÃ¡rio chamadoÂ `jose`.

Se conecte no usuÃ¡rioÂ `jose`Â atravÃ©s doÂ `ssh`. ApÃ³s realizar a conexÃ£o, utilize o comandoÂ `whoami`Â para garantir que vocÃª estÃ¡ logado com outro usuÃ¡rio.

VER OPINIÃƒO DO INSTRUTOR

Para realizar uma conexÃ£oÂ `ssh`, basta indicar para o comando o nome do usuÃ¡rio e oÂ _ip_Â da mÃ¡quina que desejamos nos conectar. No nosso caso, utilizaremosÂ `localhost`, pois a conexÃ£o serÃ¡ na nossa prÃ³pria mÃ¡quina:

```java
$ ssh jose@localhost
jose@localhost's password:
```

Ao executar o comandoÂ `whoami`, podemos perceber que estamos logados com o usuÃ¡rioÂ `jose`:

```shell
$ whoami
jose
```

Para desconectar, basta usar o comandoÂ `exit`:

```bash
$ exit
logout
Connection to localhost closed.
```
### Transferindo arquivos com scp

Agora nÃ³s iremos transferir um arquivo para uma mÃ¡quina remota utilizando o comandoÂ `scp`.

VocÃª pode escolher um arquivo de sua preferÃªncia para transferir. Caso queira, pode transferir o diretÃ³rioÂ `workspace`, criado anteriormente, ou o diretÃ³rioÂ `scripts`Â (nÃ£o se esqueÃ§a de utilizar a opÃ§Ã£o -r caso escolha transferir um diretÃ³rio). Para transferir um arquivo, vamos compactar um dos diretÃ³rios (lembre-se de alterar o nome do diretÃ³rio caso seja necessÃ¡rio):

```python
$ zip -r work.zip workspace/
```

Utilize o comandoÂ `scp`Â para copiar o arquivo para a pasta do usuÃ¡rioÂ `jose`, que Ã© um usuÃ¡rio de sua mÃ¡quina. Se logue com o usuÃ¡rioÂ `jose`Â e verifique se o arquivo foi copiado.

VER OPINIÃƒO DO INSTRUTOR

Para realizar a cÃ³pia, informamos o nome do arquivo para o comandoÂ `scp`Â junto com o nome do usuÃ¡rio,Â _ip_Â e local onde copiaremos o arquivo na mÃ¡quina remota:

```ruby
$ scp work.zip jose@localhost:~/
```

OÂ `~`Â representa o diretÃ³rio do usuÃ¡rio, que nesse caso Ã©Â `/home/jose/`.

Vamos nos conectar no usuÃ¡rioÂ `jose`Â viaÂ `ssh`Â e verificar se o arquivoÂ `work.zip`Â se encontra no diretÃ³rio do usuÃ¡rio:

```shell
$ ssh jose@localhost
jose@localhost's password:

$ whoami
jose

$ ls
examples.desktop  work.zip
```

Como podemos ver, o arquivo foi copiado.

Lembre-se que o comandoÂ `scp`Â suporta a opÃ§Ã£oÂ `-r`Â para realizar cÃ³pia de diretÃ³rios.
